{"ast":null,"code":"/**\n * 실제 엑셀 데이터 처리 및 보간 통합 모듈\n */\nimport { FARM_CODES } from './dataProcessor';\nimport { readExcelFile, worksheetToJson, parseEnvironmentData, parseGrowthData, parseManagementData, parseControlData, interpolateMultipleFields, analyzeDataQuality, detectAndHandleOutliers } from './excelReader';\n\n// 실제 엑셀 파일이 있는지 확인하고 없으면 가상 데이터 사용\nlet USE_REAL_DATA = false;\n\n/**\n * 실제 엑셀 데이터 로딩 및 처리\n */\nexport const loadRealExcelData = async (filters = {}) => {\n  const {\n    farmCodes = Object.keys(FARM_CODES),\n    startDate = '2020-01-01',\n    endDate = '2021-12-31',\n    dataTypes = ['environment', 'growth', 'management', 'control'],\n    interpolationMethod = 'linear',\n    handleOutliers = true\n  } = filters;\n  const result = {};\n  for (const farmCode of farmCodes) {\n    if (!FARM_CODES[farmCode]) continue;\n    const farmInfo = FARM_CODES[farmCode];\n    result[farmCode] = {};\n\n    // 각 데이터 타입별로 처리\n    for (const dataType of dataTypes) {\n      try {\n        const data = await loadAndProcessDataType(farmCode, farmInfo, dataType, {\n          startDate,\n          endDate,\n          interpolationMethod,\n          handleOutliers\n        });\n        result[farmCode][dataType] = data;\n      } catch (error) {\n        console.warn(`${farmCode}의 ${dataType} 데이터 로딩 실패:`, error);\n        // 실패시 빈 배열 반환\n        result[farmCode][dataType] = [];\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * 특정 농장의 특정 데이터 타입 로딩 및 처리\n */\nconst loadAndProcessDataType = async (farmCode, farmInfo, dataType, options) => {\n  const {\n    startDate,\n    endDate,\n    interpolationMethod,\n    handleOutliers\n  } = options;\n\n  // 실제 엑셀 파일 경로 생성\n  const filePath = getExcelFilePath(farmCode, dataType);\n  if (!filePath) {\n    console.warn(`${farmCode}의 ${dataType} 파일 경로를 찾을 수 없습니다.`);\n    return [];\n  }\n\n  // 엑셀 파일 읽기 시도\n  const workbook = await readExcelFile(filePath);\n  if (!workbook) {\n    console.warn(`${farmCode}의 ${dataType} 엑셀 파일을 읽을 수 없습니다: ${filePath}`);\n    return [];\n  }\n\n  // 첫 번째 시트 가져오기\n  const sheetName = workbook.SheetNames[0];\n  const worksheet = workbook.Sheets[sheetName];\n  if (!worksheet) {\n    console.warn(`${farmCode}의 ${dataType} 워크시트를 찾을 수 없습니다.`);\n    return [];\n  }\n\n  // 워크시트를 JSON으로 변환\n  const rawData = worksheetToJson(worksheet, {\n    header: 1,\n    // 첫 번째 행을 헤더로 사용\n    defval: null // 빈 셀은 null로\n  });\n  if (rawData.length === 0) {\n    console.warn(`${farmCode}의 ${dataType} 데이터가 비어있습니다.`);\n    return [];\n  }\n\n  // 데이터 타입별 파싱\n  let parsedData = [];\n  switch (dataType) {\n    case 'environment':\n      parsedData = parseEnvironmentData(rawData, farmCode, farmInfo);\n      break;\n    case 'growth':\n      parsedData = parseGrowthData(rawData, farmCode, farmInfo);\n      break;\n    case 'management':\n      parsedData = parseManagementData(rawData, farmCode, farmInfo);\n      break;\n    case 'control':\n      parsedData = parseControlData(rawData, farmCode, farmInfo);\n      break;\n    default:\n      console.warn(`알 수 없는 데이터 타입: ${dataType}`);\n      return [];\n  }\n\n  // 날짜 범위 필터링\n  const filteredData = filterByDateRange(parsedData, startDate, endDate);\n  if (filteredData.length === 0) {\n    console.warn(`${farmCode}의 ${dataType} 데이터가 날짜 범위 필터 후 비어있습니다.`);\n    return [];\n  }\n\n  // 데이터 품질 분석\n  const qualityAnalysis = analyzeDataQuality(filteredData, getFieldsForDataType(dataType));\n  console.log(`${farmCode} ${dataType} 데이터 품질:`, qualityAnalysis);\n\n  // 데이터 보간\n  const interpolatedData = performInterpolation(filteredData, dataType, interpolationMethod);\n\n  // 이상치 처리\n  let finalData = interpolatedData;\n  if (handleOutliers) {\n    finalData = performOutlierHandling(interpolatedData, dataType);\n  }\n\n  // 날짜순 정렬\n  finalData.sort((a, b) => {\n    const dateA = new Date(a.datetime || a.date);\n    const dateB = new Date(b.datetime || b.date);\n    return dateA - dateB;\n  });\n  console.log(`${farmCode} ${dataType} 최종 데이터 개수: ${finalData.length}`);\n  return finalData;\n};\n\n/**\n * 엑셀 파일 경로 생성\n */\nconst getExcelFilePath = (farmCode, dataType) => {\n  var _fileMapping$farmCode;\n  // 실제 파일 경로 매핑\n  const fileMapping = {\n    'PF_0021128': {\n      environment: '/api/excel/2020_딸기_대구_PF_0021128_01/시설원예_시간기준_환경정보_2025.08.21.xlsx',\n      growth: '/api/excel/2020_딸기_대구_PF_0021128_01/시설원예_생육정보_2025.08.21.xlsx',\n      management: '/api/excel/2020_딸기_대구_PF_0021128_01/시설원예_경영정보_출하량_2025.08.21.xlsx',\n      control: '/api/excel/2020_딸기_대구_PF_0021128_01/시설원예_시간기준_제어정보_2025.08.21.xlsx'\n    },\n    'PF_0010052': {\n      environment: '/api/excel/2020_딸기_전남_PF_0010052_01/시설원예_시간기준_환경정보_2025.08.21.xlsx',\n      growth: '/api/excel/2020_딸기_전남_PF_0010052_01/시설원예_생육정보_2025.08.21.xlsx',\n      management: '/api/excel/2020_딸기_전남_PF_0010052_01/시설원예_경영정보_출하량_2025.08.21.xlsx',\n      control: '/api/excel/2020_딸기_전남_PF_0010052_01/시설원예_시간기준_제어정보_2025.08.21.xlsx'\n    }\n    // 다른 농장들도 추가...\n  };\n  return ((_fileMapping$farmCode = fileMapping[farmCode]) === null || _fileMapping$farmCode === void 0 ? void 0 : _fileMapping$farmCode[dataType]) || null;\n};\n\n/**\n * 날짜 범위 필터링\n */\nconst filterByDateRange = (data, startDate, endDate) => {\n  const start = new Date(startDate);\n  const end = new Date(endDate);\n  return data.filter(item => {\n    const itemDate = new Date(item.datetime || item.date);\n    return itemDate >= start && itemDate <= end;\n  });\n};\n\n/**\n * 데이터 타입별 필드 목록 반환\n */\nconst getFieldsForDataType = dataType => {\n  const fieldMapping = {\n    environment: ['temperature', 'humidity', 'co2', 'lightIntensity', 'soilMoisture', 'ph'],\n    growth: ['plantHeight', 'leafLength', 'leafWidth', 'stemDiameter', 'fruitCount', 'fruitWeight', 'healthScore'],\n    management: ['yieldAmount', 'revenue', 'cost', 'profit', 'pricePerKg', 'efficiency'],\n    control: ['heatingSetpoint', 'ventilationRate']\n  };\n  return fieldMapping[dataType] || [];\n};\n\n/**\n * 데이터 보간 수행\n */\nconst performInterpolation = (data, dataType, method) => {\n  const fields = getFieldsForDataType(dataType);\n  const numericFields = fields.filter(field => field !== 'growthStage' && !field.includes('Status'));\n  return interpolateMultipleFields(data, numericFields, method);\n};\n\n/**\n * 이상치 처리 수행\n */\nconst performOutlierHandling = (data, dataType) => {\n  const fields = getFieldsForDataType(dataType);\n  const numericFields = fields.filter(field => field !== 'growthStage' && !field.includes('Status'));\n  let result = data;\n  numericFields.forEach(field => {\n    result = detectAndHandleOutliers(result, field, 'iqr', 'cap');\n  });\n  return result;\n};\n\n/**\n * 실제 데이터와 가상 데이터 통합 로더\n */\nexport const loadIntegratedData = async (filters = {}) => {\n  try {\n    // 실제 데이터 로딩 시도\n    console.log('실제 엑셀 데이터 로딩 시도...');\n    const realData = await loadRealExcelData(filters);\n\n    // 실제 데이터가 있는지 확인\n    const hasRealData = Object.values(realData).some(farmData => Object.values(farmData).some(typeData => typeData.length > 0));\n    if (hasRealData) {\n      console.log('실제 엑셀 데이터 사용');\n      USE_REAL_DATA = true;\n      return realData;\n    } else {\n      console.log('실제 엑셀 데이터가 없어 가상 데이터 사용');\n      USE_REAL_DATA = false;\n      // 가상 데이터 생성 (기존 함수 사용)\n      const {\n        generateIntegratedData\n      } = await import('./dataProcessor');\n      return generateIntegratedData(filters);\n    }\n  } catch (error) {\n    console.error('데이터 로딩 중 오류 발생:', error);\n    console.log('오류로 인해 가상 데이터 사용');\n    USE_REAL_DATA = false;\n    // 가상 데이터 생성 (기존 함수 사용)\n    const {\n      generateIntegratedData\n    } = await import('./dataProcessor');\n    return generateIntegratedData(filters);\n  }\n};\n\n/**\n * 현재 사용 중인 데이터 타입 확인\n */\nexport const isUsingRealData = () => USE_REAL_DATA;\n\n/**\n * 데이터 통계 정보 생성\n */\nexport const generateDataStatistics = data => {\n  const stats = {\n    totalRecords: 0,\n    dataTypes: {},\n    farms: {},\n    dateRange: {\n      start: null,\n      end: null\n    },\n    dataQuality: {}\n  };\n  Object.keys(data).forEach(farmCode => {\n    var _FARM_CODES$farmCode;\n    const farmData = data[farmCode];\n    stats.farms[farmCode] = {\n      name: ((_FARM_CODES$farmCode = FARM_CODES[farmCode]) === null || _FARM_CODES$farmCode === void 0 ? void 0 : _FARM_CODES$farmCode.name) || farmCode,\n      totalRecords: 0,\n      dataTypes: {}\n    };\n    Object.keys(farmData).forEach(dataType => {\n      const typeData = farmData[dataType];\n      const recordCount = typeData.length;\n      stats.totalRecords += recordCount;\n      stats.farms[farmCode].totalRecords += recordCount;\n      stats.farms[farmCode].dataTypes[dataType] = recordCount;\n      if (!stats.dataTypes[dataType]) {\n        stats.dataTypes[dataType] = 0;\n      }\n      stats.dataTypes[dataType] += recordCount;\n\n      // 날짜 범위 계산\n      if (recordCount > 0) {\n        const dates = typeData.map(item => new Date(item.datetime || item.date)).sort();\n        const firstDate = dates[0];\n        const lastDate = dates[dates.length - 1];\n        if (!stats.dateRange.start || firstDate < stats.dateRange.start) {\n          stats.dateRange.start = firstDate;\n        }\n        if (!stats.dateRange.end || lastDate > stats.dateRange.end) {\n          stats.dateRange.end = lastDate;\n        }\n      }\n    });\n  });\n  return stats;\n};\n\n/**\n * 데이터 보간 보고서 생성\n */\nexport const generateInterpolationReport = (originalData, interpolatedData) => {\n  const report = {\n    summary: {\n      originalRecords: 0,\n      interpolatedRecords: 0,\n      interpolationRate: 0\n    },\n    byField: {}\n  };\n\n  // 필드별 보간 통계 계산 로직\n  // (구현 복잡도로 인해 기본 구조만 제공)\n\n  return report;\n};","map":{"version":3,"names":["FARM_CODES","readExcelFile","worksheetToJson","parseEnvironmentData","parseGrowthData","parseManagementData","parseControlData","interpolateMultipleFields","analyzeDataQuality","detectAndHandleOutliers","USE_REAL_DATA","loadRealExcelData","filters","farmCodes","Object","keys","startDate","endDate","dataTypes","interpolationMethod","handleOutliers","result","farmCode","farmInfo","dataType","data","loadAndProcessDataType","error","console","warn","options","filePath","getExcelFilePath","workbook","sheetName","SheetNames","worksheet","Sheets","rawData","header","defval","length","parsedData","filteredData","filterByDateRange","qualityAnalysis","getFieldsForDataType","log","interpolatedData","performInterpolation","finalData","performOutlierHandling","sort","a","b","dateA","Date","datetime","date","dateB","_fileMapping$farmCode","fileMapping","environment","growth","management","control","start","end","filter","item","itemDate","fieldMapping","method","fields","numericFields","field","includes","forEach","loadIntegratedData","realData","hasRealData","values","some","farmData","typeData","generateIntegratedData","isUsingRealData","generateDataStatistics","stats","totalRecords","farms","dateRange","dataQuality","_FARM_CODES$farmCode","name","recordCount","dates","map","firstDate","lastDate","generateInterpolationReport","originalData","report","summary","originalRecords","interpolatedRecords","interpolationRate","byField"],"sources":["/DATA1/elcom/aisf2/aisf/frontend/src/utils/realDataProcessor.js"],"sourcesContent":["/**\n * 실제 엑셀 데이터 처리 및 보간 통합 모듈\n */\nimport { FARM_CODES } from './dataProcessor';\nimport { \n  readExcelFile, \n  worksheetToJson, \n  parseEnvironmentData,\n  parseGrowthData,\n  parseManagementData,\n  parseControlData,\n  interpolateMultipleFields,\n  analyzeDataQuality,\n  detectAndHandleOutliers\n} from './excelReader';\n\n// 실제 엑셀 파일이 있는지 확인하고 없으면 가상 데이터 사용\nlet USE_REAL_DATA = false;\n\n/**\n * 실제 엑셀 데이터 로딩 및 처리\n */\nexport const loadRealExcelData = async (filters = {}) => {\n  const {\n    farmCodes = Object.keys(FARM_CODES),\n    startDate = '2020-01-01',\n    endDate = '2021-12-31',\n    dataTypes = ['environment', 'growth', 'management', 'control'],\n    interpolationMethod = 'linear',\n    handleOutliers = true\n  } = filters;\n\n  const result = {};\n  \n  for (const farmCode of farmCodes) {\n    if (!FARM_CODES[farmCode]) continue;\n    \n    const farmInfo = FARM_CODES[farmCode];\n    result[farmCode] = {};\n    \n    // 각 데이터 타입별로 처리\n    for (const dataType of dataTypes) {\n      try {\n        const data = await loadAndProcessDataType(farmCode, farmInfo, dataType, {\n          startDate,\n          endDate,\n          interpolationMethod,\n          handleOutliers\n        });\n        \n        result[farmCode][dataType] = data;\n      } catch (error) {\n        console.warn(`${farmCode}의 ${dataType} 데이터 로딩 실패:`, error);\n        // 실패시 빈 배열 반환\n        result[farmCode][dataType] = [];\n      }\n    }\n  }\n  \n  return result;\n};\n\n/**\n * 특정 농장의 특정 데이터 타입 로딩 및 처리\n */\nconst loadAndProcessDataType = async (farmCode, farmInfo, dataType, options) => {\n  const { startDate, endDate, interpolationMethod, handleOutliers } = options;\n  \n  // 실제 엑셀 파일 경로 생성\n  const filePath = getExcelFilePath(farmCode, dataType);\n  \n  if (!filePath) {\n    console.warn(`${farmCode}의 ${dataType} 파일 경로를 찾을 수 없습니다.`);\n    return [];\n  }\n  \n  // 엑셀 파일 읽기 시도\n  const workbook = await readExcelFile(filePath);\n  \n  if (!workbook) {\n    console.warn(`${farmCode}의 ${dataType} 엑셀 파일을 읽을 수 없습니다: ${filePath}`);\n    return [];\n  }\n  \n  // 첫 번째 시트 가져오기\n  const sheetName = workbook.SheetNames[0];\n  const worksheet = workbook.Sheets[sheetName];\n  \n  if (!worksheet) {\n    console.warn(`${farmCode}의 ${dataType} 워크시트를 찾을 수 없습니다.`);\n    return [];\n  }\n  \n  // 워크시트를 JSON으로 변환\n  const rawData = worksheetToJson(worksheet, {\n    header: 1, // 첫 번째 행을 헤더로 사용\n    defval: null // 빈 셀은 null로\n  });\n  \n  if (rawData.length === 0) {\n    console.warn(`${farmCode}의 ${dataType} 데이터가 비어있습니다.`);\n    return [];\n  }\n  \n  // 데이터 타입별 파싱\n  let parsedData = [];\n  \n  switch (dataType) {\n    case 'environment':\n      parsedData = parseEnvironmentData(rawData, farmCode, farmInfo);\n      break;\n    case 'growth':\n      parsedData = parseGrowthData(rawData, farmCode, farmInfo);\n      break;\n    case 'management':\n      parsedData = parseManagementData(rawData, farmCode, farmInfo);\n      break;\n    case 'control':\n      parsedData = parseControlData(rawData, farmCode, farmInfo);\n      break;\n    default:\n      console.warn(`알 수 없는 데이터 타입: ${dataType}`);\n      return [];\n  }\n  \n  // 날짜 범위 필터링\n  const filteredData = filterByDateRange(parsedData, startDate, endDate);\n  \n  if (filteredData.length === 0) {\n    console.warn(`${farmCode}의 ${dataType} 데이터가 날짜 범위 필터 후 비어있습니다.`);\n    return [];\n  }\n  \n  // 데이터 품질 분석\n  const qualityAnalysis = analyzeDataQuality(filteredData, getFieldsForDataType(dataType));\n  console.log(`${farmCode} ${dataType} 데이터 품질:`, qualityAnalysis);\n  \n  // 데이터 보간\n  const interpolatedData = performInterpolation(filteredData, dataType, interpolationMethod);\n  \n  // 이상치 처리\n  let finalData = interpolatedData;\n  if (handleOutliers) {\n    finalData = performOutlierHandling(interpolatedData, dataType);\n  }\n  \n  // 날짜순 정렬\n  finalData.sort((a, b) => {\n    const dateA = new Date(a.datetime || a.date);\n    const dateB = new Date(b.datetime || b.date);\n    return dateA - dateB;\n  });\n  \n  console.log(`${farmCode} ${dataType} 최종 데이터 개수: ${finalData.length}`);\n  \n  return finalData;\n};\n\n/**\n * 엑셀 파일 경로 생성\n */\nconst getExcelFilePath = (farmCode, dataType) => {\n  // 실제 파일 경로 매핑\n  const fileMapping = {\n    'PF_0021128': {\n      environment: '/api/excel/2020_딸기_대구_PF_0021128_01/시설원예_시간기준_환경정보_2025.08.21.xlsx',\n      growth: '/api/excel/2020_딸기_대구_PF_0021128_01/시설원예_생육정보_2025.08.21.xlsx',\n      management: '/api/excel/2020_딸기_대구_PF_0021128_01/시설원예_경영정보_출하량_2025.08.21.xlsx',\n      control: '/api/excel/2020_딸기_대구_PF_0021128_01/시설원예_시간기준_제어정보_2025.08.21.xlsx'\n    },\n    'PF_0010052': {\n      environment: '/api/excel/2020_딸기_전남_PF_0010052_01/시설원예_시간기준_환경정보_2025.08.21.xlsx',\n      growth: '/api/excel/2020_딸기_전남_PF_0010052_01/시설원예_생육정보_2025.08.21.xlsx',\n      management: '/api/excel/2020_딸기_전남_PF_0010052_01/시설원예_경영정보_출하량_2025.08.21.xlsx',\n      control: '/api/excel/2020_딸기_전남_PF_0010052_01/시설원예_시간기준_제어정보_2025.08.21.xlsx'\n    }\n    // 다른 농장들도 추가...\n  };\n  \n  return fileMapping[farmCode]?.[dataType] || null;\n};\n\n/**\n * 날짜 범위 필터링\n */\nconst filterByDateRange = (data, startDate, endDate) => {\n  const start = new Date(startDate);\n  const end = new Date(endDate);\n  \n  return data.filter(item => {\n    const itemDate = new Date(item.datetime || item.date);\n    return itemDate >= start && itemDate <= end;\n  });\n};\n\n/**\n * 데이터 타입별 필드 목록 반환\n */\nconst getFieldsForDataType = (dataType) => {\n  const fieldMapping = {\n    environment: ['temperature', 'humidity', 'co2', 'lightIntensity', 'soilMoisture', 'ph'],\n    growth: ['plantHeight', 'leafLength', 'leafWidth', 'stemDiameter', 'fruitCount', 'fruitWeight', 'healthScore'],\n    management: ['yieldAmount', 'revenue', 'cost', 'profit', 'pricePerKg', 'efficiency'],\n    control: ['heatingSetpoint', 'ventilationRate']\n  };\n  \n  return fieldMapping[dataType] || [];\n};\n\n/**\n * 데이터 보간 수행\n */\nconst performInterpolation = (data, dataType, method) => {\n  const fields = getFieldsForDataType(dataType);\n  const numericFields = fields.filter(field => \n    field !== 'growthStage' && !field.includes('Status')\n  );\n  \n  return interpolateMultipleFields(data, numericFields, method);\n};\n\n/**\n * 이상치 처리 수행\n */\nconst performOutlierHandling = (data, dataType) => {\n  const fields = getFieldsForDataType(dataType);\n  const numericFields = fields.filter(field => \n    field !== 'growthStage' && !field.includes('Status')\n  );\n  \n  let result = data;\n  \n  numericFields.forEach(field => {\n    result = detectAndHandleOutliers(result, field, 'iqr', 'cap');\n  });\n  \n  return result;\n};\n\n/**\n * 실제 데이터와 가상 데이터 통합 로더\n */\nexport const loadIntegratedData = async (filters = {}) => {\n  try {\n    // 실제 데이터 로딩 시도\n    console.log('실제 엑셀 데이터 로딩 시도...');\n    const realData = await loadRealExcelData(filters);\n    \n    // 실제 데이터가 있는지 확인\n    const hasRealData = Object.values(realData).some(farmData => \n      Object.values(farmData).some(typeData => typeData.length > 0)\n    );\n    \n    if (hasRealData) {\n      console.log('실제 엑셀 데이터 사용');\n      USE_REAL_DATA = true;\n      return realData;\n    } else {\n      console.log('실제 엑셀 데이터가 없어 가상 데이터 사용');\n      USE_REAL_DATA = false;\n      // 가상 데이터 생성 (기존 함수 사용)\n      const { generateIntegratedData } = await import('./dataProcessor');\n      return generateIntegratedData(filters);\n    }\n  } catch (error) {\n    console.error('데이터 로딩 중 오류 발생:', error);\n    console.log('오류로 인해 가상 데이터 사용');\n    USE_REAL_DATA = false;\n    // 가상 데이터 생성 (기존 함수 사용)\n    const { generateIntegratedData } = await import('./dataProcessor');\n    return generateIntegratedData(filters);\n  }\n};\n\n/**\n * 현재 사용 중인 데이터 타입 확인\n */\nexport const isUsingRealData = () => USE_REAL_DATA;\n\n/**\n * 데이터 통계 정보 생성\n */\nexport const generateDataStatistics = (data) => {\n  const stats = {\n    totalRecords: 0,\n    dataTypes: {},\n    farms: {},\n    dateRange: {\n      start: null,\n      end: null\n    },\n    dataQuality: {}\n  };\n  \n  Object.keys(data).forEach(farmCode => {\n    const farmData = data[farmCode];\n    stats.farms[farmCode] = {\n      name: FARM_CODES[farmCode]?.name || farmCode,\n      totalRecords: 0,\n      dataTypes: {}\n    };\n    \n    Object.keys(farmData).forEach(dataType => {\n      const typeData = farmData[dataType];\n      const recordCount = typeData.length;\n      \n      stats.totalRecords += recordCount;\n      stats.farms[farmCode].totalRecords += recordCount;\n      stats.farms[farmCode].dataTypes[dataType] = recordCount;\n      \n      if (!stats.dataTypes[dataType]) {\n        stats.dataTypes[dataType] = 0;\n      }\n      stats.dataTypes[dataType] += recordCount;\n      \n      // 날짜 범위 계산\n      if (recordCount > 0) {\n        const dates = typeData.map(item => new Date(item.datetime || item.date)).sort();\n        const firstDate = dates[0];\n        const lastDate = dates[dates.length - 1];\n        \n        if (!stats.dateRange.start || firstDate < stats.dateRange.start) {\n          stats.dateRange.start = firstDate;\n        }\n        if (!stats.dateRange.end || lastDate > stats.dateRange.end) {\n          stats.dateRange.end = lastDate;\n        }\n      }\n    });\n  });\n  \n  return stats;\n};\n\n/**\n * 데이터 보간 보고서 생성\n */\nexport const generateInterpolationReport = (originalData, interpolatedData) => {\n  const report = {\n    summary: {\n      originalRecords: 0,\n      interpolatedRecords: 0,\n      interpolationRate: 0\n    },\n    byField: {}\n  };\n  \n  // 필드별 보간 통계 계산 로직\n  // (구현 복잡도로 인해 기본 구조만 제공)\n  \n  return report;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}